# Multiprocessing: threads
_COSC 208, Introduction to Computer Systems, 2022-04-22_

## Announcements
* Project 4 due Thursday, May 5

## Outline
* Warm-up
* Threads

## Warm-up
* _Consider the following processes:_

| Process | Arrival time   | Duration | 
|---------|----------------|----------|
| A       | 0              | 30       |
| B       | 10             | 40       |
| C       | 10             | 15       |
| D       | 20             | 10       |

* Q1: _Draw the schedule for the above processes using a First In First Out (FIFO) scheduling algorithm._
    ```
    ┌──────────────────┬────────────────────────┬─────────┬──────┐
    │ A                │ B                      │ C       │ D    │
    └──────────────────┴────────────────────────┴─────────┴──────┘
    0                  30                       70        85     95
    ```
* Q2: _Calculate the turnaround time for each process._
    * A = 30 - 0 = 30
    * B = 70 - 10 = 60
    * C = 85 - 10 = 75
    * D = 95 - 20 = 75
* Q3: _Draw the schedule for the above processes using a Shortest Job First (SJF) scheduling algorithm._
    ```
    ┌──────────────────┬──────┬─────────┬────────────────────────┐
    │ A                │ D    │ C       │ B                      │
    └──────────────────┴──────┴─────────┴────────────────────────┘
    0                  30     40        55                       95            
    ```
* Q4: _Calculate the turnaround time for each process._
    * A = 30 - 0 = 30
    * B = 95 - 10 = 85
    * C = 55 - 10 = 45
    * D = 40 - 20 = 20
* Q5: _Draw the schedule for the above processes using a Shortest Time to Completion First (STCF) scheduling algorithm._
    ```
    ┌─────┬─────────┬──────┬────────────┬────────────────────────┐
    │ A   │ C       │ D    │ A          │ B                      │
    └─────┴─────────┴──────┴────────────┴────────────────────────┘
    0     10        25     35           55                       95            
    ```
* Q6: _Calculate the turnaround time and wait time for each process._
    * Turnaround
        * A = 55 - 0 = 55
        * B = 95 - 10 = 85
        * C = 25 - 10 = 15
        * D = 35 - 20 = 15
    * Wait time
        * A = (0 - 0) + (35 - 10) = 25
        * B = (55 - 10) = 45
        * C = (10 - 10) = 0
        * D = (25 - 20) = 5
* Q7: _Draw the schedule for the above processes using a Round Robin (RR) scheduling algorithm with a quantum of 10._
    ```
    ┌──────┬──────┬──────┬──────┬──────┬──────┬───┬──────┬────────────┐
    │ A    │ B    │ C    │ D    │ A    │ B    │ C │ A    │ B          │
    └──────┴──────┴──────┴──────┴──────┴──────┴───┴──────┴────────────┘
    0      10     20     30     40     50     60  65     75           95            
    ```
* Q8: _Calculate the turnaround time and wait time for each process._
    * Turnaround
        * A = 75 - 0 = 75
        * B = 95 - 10 = 85
        * C = 65 - 10 = 55
        * D = 40 - 20 = 20
    * Wait time
        * A = (0 - 0) + (40 - 10) + (65 - 50) = 45
        * B = (10 - 10) + (50 - 20) + (75 - 60) = 45
        * C = (20 - 10) + (60 - 30) = 40
        * D = (30 - 20) = 10

## Threads
* Threads are multiple execution contexts within the **same process**
    * Processes are multiple execution contexts within the **same machine**
* Because threads are within the same process, they share all of the process’s resources—memory, CPU time, file descriptors (i.e., open files), etc.
* Consequently, two threads can update the same variable
    ```C
    void *thread1_main(void *arg) {
        int *x = (int *)arg;
        *x += 1;
        return NULL;
    }
    void *thread2_main(void *arg) {
        int *y = (int *)arg;
        *y += 2;
        return NULL;
    }
    int main() {
        int *z = malloc(sieof(int));
        *z = 0;
        // Start thread running thread1_main(z)
        // Start thread running thread2_main(z)
        // Wait for threads to finish
        printf("z is %d\n", *z);
    }
    ```
    ```
    z is 3
    ```
    * Two processes cannot update the same variable—memory is not shared; must use inter-process communication mechanism to share information
* Q9: _What are all possible outputs produced by this program?_
    ```C
    void *thread_main(void *arg) {
        char *id = (char *)arg;
        printf("I am thread %c\n", *id);
        return NULL;
    }
    int main() {
        char a = 'A';
        char b = 'B';
        // Start thread running thread_main(&a)
        // Start thread running thread_main(&b)
        // Wait for threads to finish
    }
    ```
    ```
    I am thread A
    I am thread B
    ```
    OR
    ```
    I am thread B
    I am thread A
    ```
* Q10: _What are all possible outputs produced by this program?_
    ```C
    void *proc1_main(void *arg) {
        int *x = (int *)arg;
        *x += 1;
        return NULL;
    }
    void *proc2_main(void *arg) {
        int *y = (int *)arg;
        *y += 2;
        return NULL;
    }
    int main() {
        int z = 0;
        int pid = fork();
        if (pid == 0) {
            proc1_main(&z);
        } else {
            proc2_main(&z);
            wait(NULL);
        }
        printf("z is %d\n", z);
    }
    ```
    ```
    z is 1
    z is 2
    ```

## Extra practice
* Q11: _What are all possible outputs produced by this program?_
    ```C
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/wait.h>
    int main() {
        int pid = fork();
        if (pid == 0) {
            printf("Child\n");
            exit(22);
        } else {
            int status = 0;
            wait(&status);
            printf("Status %d\n", WEXITSTATUS(status));
            exit(44);
        }
    }
    ```
    ```
    Child
    Status 22
    ```