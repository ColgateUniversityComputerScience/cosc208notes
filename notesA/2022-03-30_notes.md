# Efficiency: memory hierarchy
_COSC 208, Introduction to Computer Systems, 2022-03-30_

## Announcements
* Project 2 due tomorrow at 11pm

## Outline
* Warm-up
* Memory hierarchy
* Data movement

## Warm-up
* Q1: _The following C code was compiled into assembly (using `clang`). For each line of assembly, indicate which original line of C code the assembly instruction was derived from._
    ```C
    1   int sum(int a, int b) {
    2       int c = a + b;
    3       return c;
    4   }
    5   int triple(int u, int v) {
    6       int r = 3;
    7       int s = sum(u, v);
    8       int t = s * r;
    9       return t;
    10   }
    11  int main() {
    12      int x = 2;
    13      int y = 3;
    14      int z = triple(x, y);
    15      return z;
    16  }
    ```
    ```
    0000000000400544 <sum>:
        400544:    d10043ff     sub    sp, sp, #0x10   // 1 
        400548:    b9000fe0     str    w0, [sp, #12]   // 1
        40054c:    b9000be1     str    w1, [sp, #8]    // 1
        400550:    b9400fe8     ldr    w8, [sp, #12]   // 2
        400554:    b9400be9     ldr    w9, [sp, #8]    // 2
        400558:    0b090108     add    w8, w8, w9      // 2
        40055c:    b90007e8     str    w8, [sp, #4]    // 2
        400560:    b94007e0     ldr    w0, [sp, #4]    // 3
        400564:    910043ff     add    sp, sp, #0x10   // 3
        400568:    d65f03c0     ret                    // 3
    000000000040056c <triple>:
        40056c:    d100c3ff     sub    sp, sp, #0x30   // 5
        400570:    f90013fe     str    x30, [sp, #32]  // 5
        400574:    b9001fe0     str    w0, [sp, #28]   // 5
        400578:    b9001be1     str    w1, [sp, #24]   // 5
        40057c:    52800068     mov    w8, #0x3        // 6
        400580:    b90017e8     str    w8, [sp, #20]   // 6
        400584:    b9401fe0     ldr    w0, [sp, #28]   // 7
        400588:    b9401be1     ldr    w1, [sp, #24]   // 7
        40058c:    97ffffee     bl     400544 <sum>    // 7
        400590:    b90013e0     str    w0, [sp, #16]   // 7
        400594:    b94013e8     ldr    w8, [sp, #16]   // 8
        400598:    b94017e9     ldr    w9, [sp, #20]   // 8
        40059c:    1b097d08     mul    w8, w8, w9      // 8
        4005a0:    b9000fe8     str    w8, [sp, #12]   // 8
        4005a4:    b9400fe0     ldr    w0, [sp, #12]   // 9
        4005a8:    f94013fe     ldr    x30, [sp, #32]  // 9
        4005ac:    9100c3ff     add    sp, sp, #0x30   // 9
        4005b0:    d65f03c0     ret                    // 9
    00000000004005b4 <main>:
        4005b4:    d10083ff     sub    sp, sp, #0x20   // 11
        4005b8:    f9000bfe     str    x30, [sp, #16]  // 11
        4005bc:    52800048     mov    w8, #0x2        // 12
        4005c0:    b9000be8     str    w8, [sp, #8]    // 12
        4005c4:    52800069     mov    w9, #0x3        // 13
        4005c8:    b90007e9     str    w9, [sp, #4]    // 13
        4005cc:    b9400be0     ldr    w0, [sp, #8]    // 14
        4005d0:    b94007e1     ldr    w1, [sp, #4]    // 14
        4005d4:    97ffffe5     bl    410056c <triple> // 14
        4005d8:    b90003e0     str    w0, [sp]        // 14
        4005dc:    b94003e0     ldr    w0, [sp]        // 15
        4005e0:    f9400bfe     ldr    x30, [sp, #16]  // 15
        4005e4:    910083ff     add    sp, sp, #0x20   // 15
        4005e8:    d65f03c0     ret                    // 15
   ```
* Q2: _Draw the contents of the stack and registers just prior to the execution of the second-to-last assembly instruction in `sum`. Assume the registers have the following initial values:_
    * `pc` = `0x4005b4` 
    * `sp` = `0xF80`
    * `x30` = `0x400488`

## Memory hierarchy
* Compares various forms of storage in terms of
    * Access latency
    * Capacity
    * Cost
    * Volatility
* Access latency
    * Let's consider a 1hz CPU, which means 1 cycle = 1 second
    * Registers — 1 cycle = 1 second
    * Caches — ~10 cycles = ~10 seconds
    * Main memory — ~100 cycles = ~2 minutes
    * Solid-state drive — ~1 million cycles = ~11.5 days
    * Hard (i.e., traditional) disk drive — ~10 million cycles = ~115 days
    * Remote (i.e., network) storage — ~20ms = ~2 years
* Storage capacity
    * Let's assume 1 byte = 1mL
    * Registers — 30 * 8B = ~250mL = ~1 cup
    * Caches (Core i7 in MacBook Pro)
        * L1 — 32KB + 32KB = 64L = ~1 tank of gas
        * L2 — 512KB * 4 cores = 2048L = ~7 bathtubs
    * Main memory = 32GB (in MacBook Pro) = ~13 olympic swimming pools
    * SSD = 1TB (in MacBook Pro) = ~Lake Moraine
* Cost
    * 2 x 16GB DRAM = ~$100 = $3.12 per GB
    * 1TB SSD = $80 = $0.08 per GB
    * 2TB HDD = $60 = $0.03 per GB
* Volatility
    * Primary storage (registers, caches, and main memory) — volatile (i.e., data is lost if power is lost)
    * Secondary storage (SSD, HDD, network storage) — non-volatile (i.e., data is preserved if power is lost)

## Data movement
* Recall: _How does data move between the CPU, main memory, and secondary storage in the von Neumann Architecture?_ — bus
* _Why does data move to/from secondary storage?_ — data stored in primary storage is lost when a machine looses power
* _Why does data move between registers and main memory?_ — not enough room in registers to store all values used by a program at runtime
* _How can we move less data?_
    * Make better use of registers — i.e., eliminate unnecessary loads/stores
    * Add additional memory to the CPU — i.e., a cache
* _How do we decide what/when to move data between the registers, cache, and CPU?_ — based on locality