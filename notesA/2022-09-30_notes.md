# C: structs; Number representation: number bases
_COSC 208, Introduction to Computer Systems, 2022-02-07_

## Announcements
* First DEI activity due Thursday @ 11pm
* Project 1 Part A due Thurs, Feb 17

## Outline
* Warm-up
* Structs
* Binary

## Warm-up
Q1: _Write a function called `count_words` that takes a string and counts the number of words in the string. Assume each word is separated by a single space, and the string will contain at least one word. For example, `"Today is Monday."` contains 3 words._
```C
int count_words(char str[]) {
    int words = 1;
    for (int i = 0; i < strlen(str); i++) {
        if (nums[i] == ' ') {
            words++;
        }
    }
    return words;
}
```

## Structs
* _How is a struct declared?_
    ```C
    struct tvshow {
        char name[100];
        int season;
    };
    ```
* _How are fields of the struct accessed?_ — with the dot (.) operator
    ```C
    struct tvshow favorite;
    strncpy(favorite.name, "Tiny House Nation", 100);
    favorite.season = 6;
    ```
* A struct is a collection of values; it is **not** an object, and hence cannot have methods associated with it
* A struct variable holds *values* for the fields of the struct; it is **not** a reference to the struct, and hence a copy of the values are passed to functions
* Q2: _What is the output of this program?_
    ```C
    struct one {
        char x;
        char y;
        short z;
    };
    struct two {
        int m;
        int n[10];
    };
    int main() {
        struct one a;
        struct two b;
        printf("%d %d\n", sizeof(struct one), sizeof(a.z));
        printf("%d %d\n", sizeof(b), sizeof(b.n));
    }
    ```
    ```
    4 2
    44 40
    ```
* Q3: _What is the output of this program?_
    ```C
    struct alpha {
        char x[10];
        int y;
    };
    struct beta {
        int b;
        int c;
    };
    int main() {
        struct alpha a = { "Colgate", 13 };
        struct beta b = { 1, 2 };
        struct beta c = { 3, 4 };
        a.y += -13;
        b.b = 5;
        c = b;
        b.c = 6;
        printf("a %s %d\n", a.x, a.y);
        printf("b %d %d\n", b.b, b.c);
        printf("c %d %d\n", c.b, c.c);
    }
    ```
    ```
    a Colgate 0
    b 5 6
    c 5 2
    ```

## Decimal (i.e., base 10)
* _How many unique values can you represent with one decimal digit?_ -- 10
* _How do you count to 13 (in base 10)?_ -- 0 (computers like to start at zero!), 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 (notice the "ones" place becomes zero and the "tens" place becomes 1), 11, 12, 13

## Binary (i.e., base 2)
* We are used to working with decimal numbers, but computers represent numbers in binary
    * A single binary digit (_bit_) can represent two unique values — 0 or 1
    * It is easier to build hardware that uses polar opposites (e.g., on/off, high/low voltage, positive/negative magnetism, etc.) than multiple levels (e.g., very high, high, moderately high, moderate, moderately low, low, very low voltage)
* _How many unique values can be represented with 2 bits?_ — 00, 01, 10, 00; 2^2 = 4
    * _3 bits?_ — 000, 001, 010, 011, 100, 101, 110, 111; 2^3 = 8
* Practice powers of two: 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192
* _How many bits are in a byte?_ -- 8 bits
* _How many unique values can be represented with 1 byte? 4 bytes? -- 256, ~4.3 billion
* _How do you count to 13 in binary?_ -- 0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101
* _Convert these binary numbers to decimal (i.e., base 10):_
    * Q4: `0b10` = 1 * 2^1 + 0 * 2^0 = 2
    * Q5: `0b11` = 1 * 2^1 + 1 * 2^0 = 2 + 1 = 3
    * Q6: `0b1010` = 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 8 + 2 = 10
    * Q7: `0b1111` = 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 8 + 4 + 2 + 1 = 15
    * Q8: `0b11001100` = 1 * 2^7 + 1 * 2^6 + 0 * 2^5 + 0 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 = 128 + 64 + 8 + 4 = 204

## Hexadecimal (i.e., base 16)
* _How many values can be represented with one hexadecimal digit?_ - 16
* _How do you count to 13 in hexadecimal?_ — 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D
* Powers of sixteen: 16, 256, 4096

## Extra practice
* Q14: _Write a struct definition to represent a date (year, month number, and day)._
    ```C
    struct date {
        int year;
        int month;
        int day;
    };
    ```
* Q15: _Write a function called `compare` that takes two date structs and returns -1 if the first date occurs before the second, 0 if the dates are equal, and 1 if the first date occurs after the second._
    ```C
    int compare(struct date a, struct date b) {
        if (a.year < b.year) {
            return -1;
        } else if (b.year < a.year) {
            return 1;
        } else {
            if (a.month < b.month) {
                return -1;
            } else if (b.month < a.month) {
                return 1;
            } else { 
                if (a.day < b.day) {
                    return -1;
                } else if (b.day < a.day) {
                    return 1;
                } else {
                    return 0;
                }
            }
        }
    }
    ```



## Pointers to structs
* _How do you get a pointer to a struct?_
    * Use address-of (`&`) operator with a parameter/local variable
        ```C
        struct tvshow {
            char name[100];
            int season;
        };
        ```
        ```C
        int main() {
            struct tvshow favorite = {"This Old House", 42};
            struct tvshow *ptr = &favorite;
        }
        ```
    * Allocate space on the heap
        ```C
        int main() {
            struct tvshow *ptr = malloc(sizeof(struct tvshow));
        }
        ```
* _How do you access a struct's fields through a pointer to the struct?_
    * `(*ptr).field`
        ```C
        printf("There are %d seasons of %s\n", (*ptr).seasons, (*ptr).name);
        ```
        * Don't do `*ptr.field` — it will try to dereference `field` not `ptr`, because `.` has higher precedence than `*`
    * `ptr->field`
        ```C
        printf("There are %d seasons of %s\n", ptr->seasons, ptr->name);
        ```
* Assume you are given the following code:
    ```C
    struct account {
        int number; // Account number
        int balance; // Current account balance
    };
    int deposit(struct account *acct, int amount);
    int transfer(struct account *from, struct amount *to, int amount);
    ```

    * Q8: _Write the `deposit` function, which adds `amount` to the balance of `acct`. The function should return the amount deposited._
        ```C
        int deposit(struct account *acct, int amount) {
            acct->balance += amount;
            return amount;
        } 
        ```

    * Q9: _Write the `transfer` function which moves `amount` from one account to another. The function should return the amount transferred if the transfer was successful or 0 otherwise._
        ```C
        int transfer(struct account *from, struct amount *to, int amount) {
            if (from->balance < amount)
                return 0;
            from->balance -= amount;
            to->balance += amount;
            return amount;
        }
        ```

## Extra practice
* _Two structs have been defined representing a queue and an item on a queue._
    ```C
    struct item {
        int value;
        struct item *next;
    };
    struct queue {
        struct item *head;
        struct item *tail;
    };
    ```
    _The `new_queue` function creates a new, empty queue._
    ```C
    struct queue *new_queue() {
        struct queue *q = malloc(sizeof(struct queue));
        q->head = NULL;
        q->tail = NULL;
        return q;
    }
    ```
* Q10: _Write a function called `enqueue` that adds a new value at the end of the queue._
    ```C
    void enqueue(int value, struct queue *q) {
        struct item *i = malloc(sizeof(struct item));
        i->value = value;
        i->next = NULL;
        if (q->tail == NULL) {
            q->head = i;
            q->tail = i;
        } else {
            q->tail->next = i;
            q->tail = i;
        }
    }
    ```
* Q11: _Write a function called `dequeue` that removes and returns the value at the head of the queue. The function should return -1 if the queue is empty._
    ```C
    int dequeue(struct queue *q) {
        if (NULL == q->head) {
            return -1;
        }
        struct item *i = q->head;
        int v = i->value;
        q->head = i->next;
        if (q->head == NULL) {
            q->tail = NULL;
        }
        free(i);
        return v;
    }
    ```
* Q12: _Write a function called `free_queue` that empties and frees a queue._
    ```C
    void free_stack(struct queue *q) {
        while (q->head != NULL) {
            dequeue(q);
        }
        free(q);
    }
    ```