# Multithreading: making programs multi-threaded (continued); Virtualization: virtual machines & containers
_COSC 208, Introduction to Computer Systems, 2022-12-02_

## Announcements
* Attend faculty candidate talks Dec 8, 13, 14, & 15 at 11:20am
    * Earn 2 points of extra credit on final exam for each talk or discussion attended (maximum of 4 points)
* Project 5 due Thursday @ 11pm 
* Final exam
    * Study guide posted on Moodle
    * Take-home portion: released next Wednesday; due Monday of finals week
    * In-class portion: Monday of finals week 9am-11am or 12pm-2pm

## Outline
* Warm-up
* Making programs multi-threaded (continued)
* Virtual machines
* Hypervisors
* CPU sharing
* VM performance

## Warm-up
Q1: _Consider the following program:_
```C
1   #include <ctype.h>
2   #include <pthread.h>
3   #include <stdio.h>
4   #include <stdlib.h>
5   #include <string.h>
6   int count_upper(char *str) {
7       int count = 0;
8       for (int i = 0; i < strlen(str); i++) {
9          if (isupper(str[i])) {
10              count++;
11          }
12      }
13      return count;
14  }
15  int main(int argc, char *argv[]) {
16      if (argc < 2) {
17          printf("Error: provide a string\n");
18          return 1;
19      }
20      char *str = argv[1];
21      pthread_t thr;
22      pthread_create(thr, NULL, &count_upper, str);
23      int count = 0;
24      pthread_join(thr, &count);
25      printf("There are %d uppercase letters\n", count);
26  }
```
_Compiling this program with `clang` results in the following warnings:_
```
buggy.c:22:20: warning: incompatible integer to pointer conversion passing 
'pthread_t' (aka 'unsigned long') to parameter of type 'pthread_t *' (aka 
'unsigned long *'); take the address with & [-Wint-conversion]
    pthread_create(thr, NULL, &count_upper, str);
                   ^~~
                   &
/usr/include/pthread.h:198:50: note: passing argument to parameter 
'__newthread' here
extern int pthread_create (pthread_t *__restrict __newthread,
                                                 ^

buggy.c:22:31: warning: incompatible function pointer types passing 
'int (*)(char *)' to parameter of type 'void *(*)(void *)' 
[-Wincompatible-function-pointer-types]
    pthread_create(thr, NULL, &count_upper, str);
                              ^~~~~~~~~~~~
/usr/include/pthread.h:200:15: note: passing argument to parameter 
'__start_routine' here
                           void *(*__start_routine) (void *),
                                   ^

buggy.c:24:23: warning: incompatible pointer types passing 
'int *' to parameter of type 'void **' [-Wincompatible-pointer-types]
    pthread_join(thr, &count);
                      ^~~~~~
/usr/include/pthread.h:215:49: note: passing argument to parameter 
'__thread_return' here
extern int pthread_join (pthread_t __th, void **__thread_return);
                                                ^
3 warnings generated.
```
_How would you change the code to fix these problems?_
* Need to pass `&thr` to `pthread_create` (instead of `thr`) on line 22
* Function executed by a thread must return `void *` and take a single `void *` parameter; replace lines 6-7 with:
    ```C
    void *count_upper(void *arg) {
        char *str = (char *)arg;
        int *count = malloc(sizeof(int));
        *count = 0;
    ```
    Also replace line 10 with:
    ```C
    *count++;
    ```
* Need to pass a double pointer to `pthread_join` on line 24; replace lines 23-25 with:
    ```C
    int *count = NULL;
    pthread_join(thr, &count);
    printf("There are %d uppercase letters\n", *count);
    ``` 

## Making programs multi-threaded
* _Assume you are given the following code:_
    ```C
    #include <ctype.h>
    #include <stdio.h>
    #include <string.h>
    int count(char *str, char ch) {
        int num = 0;
        while (*str != '\0') {
            if (tolower(*str) == ch) {
                num++;
            }
            str++;
        }
        return num;
    }
    int main(int argc, char *argv[]) {
        if (argc < 2) {
            printf("Error: provide a string\n");
            return 1;
        }
        char *str = argv[1];
        char *vowels = "aeiou";
        int counts[strlen(vowels)];
        for (int i = 0; i < strlen(vowels); i++) {
            counts[i] = count(str, vowels[i]);
        }

        for (int i = 0; i < strlen(vowels); i++) {
            printf("%c %d\n", vowels[i], counts[i]);
        }
    }
    ```
* Q2: *Write a function called  `count_wrapper` that has the signature required for a thread function and calls the `count` function. (Hint: you'll need to declare a `struct` that contains all of the parameters required for `count`.)*
    ```C
    struct count_args {
        char *str;
        char ch;
    };
    void *count_wrapper(void *arg) {
        struct count_args *cargs = (struct count_args *)arg;
        int *result = malloc(sizeof(int));
        *result = count(cargs->str, cargs->ch);
        return result;
    }
    ```
* Q3: *Re-write `main` to create/wait for threads that execute `count_wrapper` (instead of calling `count` sequentially).*
    ```C
    int main(int argc, char *argv[]) {
        if (argc < 2) {
            printf("Error: provide a string\n");
            return 1;
        }
        char *str = argv[1];
        char *vowels = "aeiou";

        // Create threads
        struct count_args args[strlen(vowels)];
        pthread_t threads[strlen(vowels)];
        for (int i = 0; i < strlen(vowels); i++) {
            args[i].str = str;
            args[i].ch = vowels[i];
            pthread_create(&(threads[i]), NULL, &count_wrapper, &(args[i]));
        }

        // Wait for threads
        for (int i = 0; i < strlen(vowels); i++) {
            int *ptr;
            pthread_join(threads[i], (void **)(&ptr));
            printf("%c %d\n", vowels[i], *ptr);
        }
    }
    ```

## Virtual machines (VMs)
* Recall: _what is the purpose of an OS?_
    * Make computer hardware easy to use—e.g., an OS knows how to load an application's executable code from persistent storage (e.g., solid state drive (SSD)) into main memory, initialize the process's memory (code, heap, stack), and make the CPU execute the application's instructions
    * Support multiprocessing—i.e., running multiple applications simultaneously or concurrently
    * Allocate and manage hardware resources—e.g., decide when/which applications can use the CPU, decide when/which memory applications can use, prevent applications from stealing/accessing another application's CPU time or memory
* What is the purpose of a virtual machine?
    * Make computer hardware flexible to use
    * Support multiple OSes running concurrently
    * Allocate and manage hardware resources—e.g., decide when/which VMs can use the CPU, decide/when which memory VMs can use, prevent VMS from stealing/accessing another VM's CPU time or memory
* What is the motivation for using a virtual machine?
    * Run multiple OSes concurrently — _why would someone one to do this?_
        * Run software only supported by a specific OS
        * Software testing
        * Server consolidation
        * Security sandboxing
    * Flexibly use hardware resources

## Hypervisors
* _What additional software layer does a computer system need to support virtual machines?_ — hypervisor
* _Where does a hypervisor reside?_
    * Type 1: on top of hardware — e.g., KVM, Xen, Hyper-V, VMware vSphere
    * Type 2: on top of host OS — e.g., VirtualBox, VMware Workstation/Fusion
* _Why is a type 1 hypervisor better than a type 2 hypervisor?_
    * Resources can be oversubscribed
    * No overhead from host OS
* _Why is a type 2 hypervisor better than a type 1 hypervisor?_
    * Easy to use

## CPU sharing
* Use same approach OS uses for sharing CPU between processes — Limited Direct Execution (LDE)
* _Recall: How does LDE work in OS?_
    * Put CPU in user mode
    * Give process exclusive access to CPU
    * Process issues a syscall to perform privileged operation
    * Timer interrupt allows OS to regain control
* To use LDE with a VM
    * Put CPU in user mode
    * Give VM exclusive access to CPU
    * Process issues a syscall -OR- OS attempts to perform privileged operation
    * Timer interrupt allows hypervisor to regain control
* Recall: _How does a process make a syscall?_ — load syscall number into register `x8` and execute `svc` instruction
* _What happens when a process makes a syscall?_
    1. CPU saves registers to the OS stack
    2. CPU switches to kernel mode
    3. CPU uses system call number to index into OS's table of syscall handlers 
    4. Branch and link to syscall handler code
    5. Restore registers from the OS stack
    6. Switch CPU to user mode
    7. Resume execution after `svc` 
* Syscalls with a type 1 hypervisor
    * Processes in virtualized OS do the same as before
    * Hypervisor’s syscall handler is invoked by hardware instead of OS’s syscall handler
    * Actually want to invoke OS's syscall handler — the hypervisor does this
    * Hypervisor knows where OS trap table is located, because populating syscall table is a privileged instruction, so hypervisor interposed on these operations when OS booted
* Steps when process in virtualized OS makes a syscall
    1. CPU saves registers to the hypervisor stack
    2. CPU switches to kernel mode
    3. CPU uses system call number to index into VM's table of syscall handlers 
    4. **Switch CPU from kernel to user mode**
    5. Branch and link to syscall handler code
    6. **Switch CPU from user to kernel mode**
    7. Restore registers from the hypervisor stack
    8. Switch CPU to user mode
    9. Resume execution after `svc`

## VM performance
* Extra work to always trap to hypervisor, which then invokes OS code
* Possible solutions
    * Hardware support — e.g., supervisor mode that is between user and kernel mode
    * Para-virtualization — modify the OS so it's aware there is a hypervisor and the two can interact directly
    * Containers — use a single OS, but create groups of processes that are isolated from other processes
        * OS's process abstraction already isolates each process's CPU time, memory, and registers, but processes can still use syscalls to pass messages to each other, wait for each other, access a common set of files, etc.