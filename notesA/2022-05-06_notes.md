# Exam 3 (Final) Review
_COSC 208, Introduction to Computer Systems, 2022-05-06_

## Announcements
* Final exam
    * Study guide posted on Moodle
    * Take-home portion due Friday, May 13 at 9am
    * In-class portion Friday May 13 9am-11am
* Finals week office hours
    * Monday 8:30am-2pm
    * Tuesday 8:30am-10am
    * Thursday 8:30am-12pm

## Outline
* Cloud computing (continued)
* Memory hierarchy
* Caching
* Processes
* Scheduling
* Threads
* Memory
* Threads

## No warm-up — Happy last day of the semester!

## Cloud computing (continued)
* Service models
    * Infrastructure-as-a-Service (IaaS)
        * Tenants lease virtual machines, virtual storage, and virtual networks
        * Tenants must manage the operating system, file system, etc.
        * E.g., Amazon EC2, Microsoft Azure, Rackspace, Google Compute Engine
    * Platform-as-a-Service (PaaS)
        * Tenants lease resources to run applications written in a specific language — Python, Java, Hadoop/MapReduce
        * Cloud provider manages the operating system, file system, and network
        * E.g., Google App Engine, Cloud Foundry, IBM Cloud
    * Function-as-a-Service (FaaS) or serverless
        * Tenants run independent snippets of code
        * E.g., Amazon Lambda
    * Software-as-a-Service (SaaS)
        * Tenants lease access to specific software
        * E.g., Salesforce, Concur, Constant Contact, Google Drive, Office 365
    * Storage-as-a-Service (STaaS)
        * E.g., Dropbox, Google Drive, iCloud
    * Ownership
        * Public - anyone can request and use resources
        * Private - resources are only available to tenants (e.g., departments) within a company or organization
        * Hybrid - tenants use a combination of public and private cloud resources
    * Q1: _For each of the following service providers, indicate what type of service they offer._
        * _Box provides secure file sharing and storage_ — Storage-as-a-Service (STaaS)
        * _Microsoft Azure provides virtual machines running Windows or Linux_ — Infrastructure-as-a-Service (IaaS)
        * _Heroku allows tenants to deploy code written in Ruby, Java, PHP, Python, Go, Scala, or Clojure_ — Platform-as-a-Service (PaaS)
        * _Oracle Supply Chain Management (SCM) is software that allows businesses to manage their supply chain_ — Software-as-a-Service (SaaS)

## Memory hierarchy
* Q2: What is the **fastest volatile** memory? — registers
* Q3: What is the **fastest non-volatile** memory? — solid state drive (SSD)
* Q4: Why is a hard disk drive (HDD) slower than a solid state drive (SSD)? — an HDD has moving parts that need to be moved into position before data can be read/written
* Q5: Why is accessing main memory (i.e., Random Access Memory (RAM)) slower than accessing a cache? — a cache is part of the CPU, but data needs to travel across a bus to move between the CPU and main memory

## Caching
* Q6: _Assume the cache size is 3 and the **optimal** cache replacement algorithm is used. Indicate what happens with the cache on each data access._
    * Access 2 — +2
    * Access 4 — +4
    * Access 1 — +1
    * Access 2 — Hit
    * Access 4 — Hit
    * Access 3 — -1/+3
    * Access 2 — Hit
    * Access 4 — Hit
    * Access 1 — -3/+1
    * Access 2 — Hit
    * Access 4 — Hit
    * Access 1 — Hit
* Q7: _Assume the cache size is 3 and the **least recently used (LRU)** cache replacement algorithm is used. Indicate what happens with the cache on each data access._
    * Access 2 — +2
    * Access 4 — +4
    * Access 1 — +1
    * Access 2 — Hit
    * Access 4 — Hit
    * Access 3 — -1/+3
    * Access 2 — Hit
    * Access 4 — Hit
    * Access 1 — -3/+1
    * Access 2 — Hit
    * Access 4 — Hit
    * Access 1 — Hit

## Processes
* Q8: _Write a program that creates a new process. The child process should print "I am a child"; the parent process should print "I am a parent; my child is CPID" (replacing CPID with the child’s PID)._
    ```C
    int main() {
        int pid = fork();
        if (pid == 0) {
            printf("I am a child\n");
        }
        else {
            printf("I am a parent; my child is %d\n", pid);
        }
    }
    ```
* Q9: _Will the output produced by your program always appear in a particular order? Why or why not?_
    * No, because the parent does not `wait` for the child to finish before printing, and the OS scheduler determines which order the processes run
    * If you included a call to `wait` before the call to `printf` in the else body, then the answer would be yes, because the parent waits for the child to finish before printing

## Scheduling
_Consider the following set of processes:_

| Process | Duration | Arrival Time |
|---------|----------|--------------|
| A       | 20       | 0            |
| B       | 15       | 0            |
| C       | 25       | 5            |
| D       | 5        | 10           |

* Q10: _Draw the schedule when a First In First Out (FIFO) scheduling algorithm is used._

```
  A                   B              C                        D
|-------------------|--------------|------------------------|----|
0                   20             35                       60   65
```

* Q11: _Compute the turnaround and wait time for each process based on the above schedule._

| Process | Turnaround | Wait |
|---------|------------|------|
| A       | 20         | 0    |
| B       | 35         | 20   |
| C       | 60         | 30   |
| D       | 55         | 50   |

* Q12: _Draw the schedule when a Shortest Job First (SJF) scheduling algorithm is used._

```
  B              D    A                   C
|--------------|----|-------------------|------------------------|
0              15   20                  40                       65
```

* Q13: _Compute the turnaround and wait time for each process based on the above schedule._

| Process | Turnaround | Wait |
|---------|------------|------|
| A       | 40         | 20   |
| B       | 15         | 0    |
| C       | 55         | 35   |
| D       | 10         | 5    |

* Q14: _Draw the schedule when a Shortest Time to Completion First (STCF) scheduling algorithm is used._

```
  B              D    A                   C
|--------------|----|-------------------|------------------------|
0              15   20                  40                       65
```

* Q15: _Compute the turnaround and wait time for each process based on the above schedule._

| Process | Turnaround | Wait |
|---------|------------|------|
| A       | 40         | 20   |
| B       | 15         | 0    |
| C       | 60         | 35   |
| D       | 10         | 5    |

* Q16: _Draw the schedule when a Round Round (RR) scheduling algorithm is used with a time quantum of 10._

```
  A         B         C         D   A          B    C
|---------|---------|---------|----|---------|----|-------------------|
0         10        20        30   35        45   50                  65
```

* Q17: _Compute the turnaround and wait time for each process based on the above schedule._

| Process | Turnaround | Wait |
|---------|------------|------|
| A       | 45         | 25   |
| B       | 50         | 35   |
| C       | 60         | 35   |
| D       | 25         | 20   |

## Threads
_A program contains the following functions:_
```C
void *dec(void *arg) {
    int *t = (int *)arg;
    *t--;
}

void *inc(void *arg) {
    int *t = (int *)arg;
    *t++;
}

void *zero(void *arg) {
    int *t = (int *)arg;
    *t = 0;
}
```
_For each of the following main methods, list **all possible outputs** the program could produce. Assume threads are only preempted if they become blocked waiting for other threads._
* Q18:
    ```C
    int main() {
        int *total = malloc(sizeof(int));
        *total = 2;
        pthread_t thrA, thrB;
        pthread_create(&thrA, NULL, &inc, total);
        pthread_create(&thrB, NULL, &inc, total);
        pthread_join(thrA, NULL);
        pthread_join(thrB, NULL);
        printf("%d\n", *total);
    }
    ```
    * `4`
* Q19:
    ```C
    int main() {
        int *total = malloc(sizeof(int));
        *total = 2;
        pthread_t thrA, thrB;
        pthread_create(&thrA, NULL, &dec, total);
        pthread_create(&thrB, NULL, &zero, total);
        pthread_join(thrA, NULL);
        pthread_join(thrB, NULL);
        printf("%d\n", *total);
    } 
    ```
    Possible outputs:
    * `0`
    * `-1`
* Q20:
    ```C
    int main() {
        int *total = malloc(sizeof(int));
        *total = 2;
        pthread_t thrA, thrB;
        pthread_create(&thrA, NULL, &zero, total);
        pthread_join(thrA, NULL);
        pthread_create(&thrB, NULL, &inc, total);
        pthread_join(thrB, NULL);
        printf("%d\n", *total);
    } 
    ```
    Possible outputs:
    * `1`

## Memory
The intended behavior of the program below is to output a string that contains multiple copies of a word (e.g., `"byebye"`). The code below compiles without warnings, but it contains multiple errors.
```C
1   #include <stdlib.h>
2   #include <string.h>
3   #include <stdio.h>
4   char *repeat(char *word, int count) {
5       char *dup = malloc(sizeof(*word) * count + 1);
6       int k = 0;
7       for (int i = 0; i < count; i++) {
8           for (int j = 0; j <= strlen(word) * count; j++) {
9               dup[k] = word[j];
10              k++;
11          }
12      }
13      free(dup);
14      return dup;
15  }
16  int main() {
17      char *orig = malloc(4);
18      strcpy(orig, "bye");
19      char *result = repeat(orig, 2);
20      printf("%s\n", result);
21  }
```
For each of the following errors produced by valgrind, describe (in 2-3 sentences) **why** the error is occurring and **how** you would modify the code to correct the error.

* Q21:
    ```
    Invalid write of size 1
        at 0x4006CA: repeat (repeat.c:9)
        by 0x400752: main (repeat.c:19)
    Address 0x5204093 is 0 bytes after a block of size 3 alloc'd
        at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
        by 0x40066B: repeat (repeat.c:5)
        by 0x400752: main (repeat.c:19)
    ```
    Not enough space was allocated for the duplicated string: `sizeof(*word)` gets the size of a single character. Use `strlen(word)` to get the number of characters in the original word.
* Q22:
    ```
    Invalid read of size 1
        at 0x4006BF: repeat (repeat.c:9)
        by 0x400752: main (repeat.c:19)
    Address 0x5204044 is 0 bytes after a block of size 4 alloc'd
        at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
        by 0x400723: main (repeat.c:17)
    ```
    The inner for loop goes beyond the end of the original word. The for loop condition should be `j < strlen(word)`.
* Q23:
    ```
    Invalid read of size 1
        at 0x4E88CD0: vfprintf (vfprintf.c:1632)
        by 0x4E8F8A8: printf (printf.c:33)
        by 0x40076B: main (repeat.c:20)
    Address 0x5204090 is 0 bytes inside a block of size 3 free'd
        at 0x4C2EDEB: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
        by 0x4006FF: repeat (repeat.c:13)
        by 0x400752: main (repeat.c:19)
    Block was alloc'd at
        at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
        by 0x40066B: repeat (repeat.c:5)
        by 0x400752: main (repeat.c:19)
    ```
    The string containing the repeated word is free'd (in `repeat`) before it is printed (in `main`). Move the call to `free` in `repeat` to after the call to `printf` in `main`.
* Q24:
    ```
    4 bytes in 1 blocks are definitely lost in loss record 1 of 1
        at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
        by 0x400723: main (repeat.c:17)
    ```
    The space for the original word (allocated in `main`) is not freed. Add `free(orig)` after the call to `repeat` in `main`.

## Threads
A program contains the following global variables and functions:
```C
void *dbl(void *arg) {
    int *t = (int *)arg;
    *t = *t * 2;
}

void *one(void *arg) {
    int *t = (int *)arg;
    *t = 1;
}
```
_For each of the following main methods, list **all possible outputs** the program could produce. Assume threads are only preempted if they become blocked waiting for other threads._

* Q25:
    ```C
    int main() {
        int *total = malloc(sizeof(int));
        *total = 3;
        pthread_t thrA, thrB;
        pthread_create(&thrA, NULL, &dbl, total);
        pthread_create(&thrB, NULL, &one, total);
        pthread_join(thrA, NULL);
        pthread_join(thrB, NULL);
        printf("%d\n", total);
    }
    ```
    * `1` (if `thrB` runs after `thrA` finishes)
    * `2` (if `thrA` runs after `thrB` finishes)
* Q26:
    ```C
    int main() {
        int *total = malloc(sizeof(int));
        *total = 3
        pthread_t thrA, thrB;
        pthread_create(&thrA, NULL, &one, total);
        pthread_join(thrA, NULL);
        pthread_create(&thrB, NULL, &dbl, total);
        pthread_join(thrB, NULL);
        printf("%d\n", total);
    }
    ```
    * `2` (`thrA` is joined, i.e., must finish, before `thrB` is created) 