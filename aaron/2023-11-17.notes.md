# Efficiency: threads
_COSC 208, Introduction to Computer Systems, 2023-11-17_

## Announcements
* Project 4 due Thurs, Dec 7

## Outline
* Warm-up
* Threads and memory
* Pthreads API

## Warm-up

* Q1: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
void *proc1_main(void *arg) {
    int *x = (int *)arg;
    *x += 1;
    return NULL;
}
void *proc2_main(void *arg) {
    int *y = (int *)arg;
    *y += 2;
    return NULL;
}
int main() {
    int *z = malloc(sizeof(int));
    *z = 0;
    int pid = fork();
    if (pid == 0) {
        proc1_main(z);
    } else {
        wait(NULL);
        proc2_main(z);
    }
    printf("z is %d\n", *z);
}
```

    z is 1
    z is 2


## Threads and memory

* Threads are multiple execution contexts within the **same process**
    * Processes are multiple execution contexts within the **same machine**
* Because threads are within the same process, they share all of the process’s resources — memory, CPU time, file descriptors (i.e., open files), etc.
* Consequently, two threads can update the same variable

* Example


```c
#include <stdio.h>
#include <stdlib.h>
void *thread1_main(void *arg) {
    int *x = (int *)arg;
    *x += 1;
    return NULL;
}
void *thread2_main(void *arg) {
    int *y = (int *)arg;
    *y += 2;
    return NULL;
}
int main() {
    int *z = malloc(sizeof(int));
    *z = 0;
    // Create thread running thread1_main(z)
    // Create thread running thread2_main(z)
    // Wait for threads to finish
    printf("z is %d\n", *z);
}
```

```
z is 3
```

* Two processes cannot update the same variable — memory is not shared; must use inter-process communication mechanism to share information

* Q2: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
void *increment(void *arg) {
    int *num = (int*)arg;
    *num += 1;
    return NULL;
}
void *zero(void *arg) {
    int *num = (int*)arg;
    *num = 0;
    return NULL;
}
int main() {
    int *i = malloc(sizeof(int));
    *i = 5;
    // Create thread running increment(i)
    // Create thread running zero(i)
    // Wait for threads to finish
    printf("i=%d\n", *i);
}
```

```
i=0
```
OR
```
i=1
```

## Pthreads API

* Can create and wait for threads to finish, just like processes, but API is different
* Use the pthreads library—`#include <pthread.h>`
* `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void * arg)`
    * `thread`—a struct that stores metadata for the thread
    * `attr`—configuration settings for the thread
    * `start_routine`—the function to start executing when the thread starts
        * Pass a pointer to a function
    * `arg`—an argument passed to the aforementioned function
    * _How do we create a new process?_—`fork`
* `int pthread_join(pthread_t thread, void **value_ptr)`
    * `thread`—the same struct passed at thread creation; used to identify the thread we want to wait for
    * `value_ptr`—the location where the function return value should be stored
        * Notice it’s a pointer to a void pointer and the `start_routine` function specified in create returns a void pointer
    * _How do we wait for a process to finish?_ — `wait` or `waitpid`

* Q3: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
void *printer(void *arg) {
    char *ch = (char*)arg;
    printf("I am %c\n", *ch);
    return NULL;
}
int main() {
    pthread_t thread1, thread2;
    char *ch = malloc(sizeof(char));
    *ch = 'P';
    pthread_create(&thread1, NULL, &printer, ch);
    pthread_join(thread1, NULL);
    *ch = 'Q';
    pthread_create(&thread2, NULL, &printer, ch);
    pthread_join(thread2, NULL);
}
```

    I am P
    I am Q


## Extra practice

* Q4: _What output is produced by the following program? (Note: there is only one possible ordering.)_


```c
/*1*/   #include <stdio.h>
/*2*/   #include <stdlib.h>
/*3*/   #include <sys/wait.h>
/*4*/   #include <unistd.h>
/*5*/   int main() {
/*6*/       printf("A\n");
/*7*/       int x = fork();
/*8*/       if (x == 0) {
/*9*/           int y = fork();
/*10*/          if (y == 0) {
/*11*/              printf("B\n");
/*12*/          }
/*13*/          else {
/*14*/              wait(NULL);
/*15*/              printf("C\n");
/*16*/          }
/*17*/      }
/*18*/      else {
/*19*/          wait(NULL);
/*20*/          printf("D\n");
/*21*/      }
/*22*/      printf("E\n");
/*23*/  }
```

    A
    B
    E
    C
    E
    D
    E


* Q5: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
void *thread_main(void *arg) {
    char *id = (char *)arg;
    printf("I am thread %c\n", *id);
    return NULL;
}
int main() {
    char *a = malloc(sizeof(char));
    *a = 'A';
    char *b = malloc(sizeof(char));
    *b = 'B';
    // Create thread running thread_main(a)
    // Create thread running thread_main(b)
    // Wait for threads to finish
}
```

```
I am thread A
I am thread B
```
OR
```
I am thread B
I am thread A
```
