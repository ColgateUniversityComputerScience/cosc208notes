# Multithreading: threads
_COSC 208, Introduction to Computer Systems, 2023-04-26_

## Announcements
* Project 5 due Thursday, May 4

## Outline
* Warm-up
* Threads and memory
* Pthreads API
* Creating multiple threads
* Returning values from threads
* Passing multiple parameters to threads

## Warm-up

_Consider the following set of processes:_

| Process | Arrival Time | Duration |
|---------|--------------|----------|
| A       | 0            | 30       |
| B       | 0            | 25       |
| C       | 5            | 15       |
| D       | 10           | 5        |

* Q1: _Draw the schedule when a Round Robin (RR) scheduling algorithm is used with a time quantum of 15._

```
  A              B              C              D    A              B       
|--------------|--------------|--------------|----|--------------|---------|
0              15             30             45   50             65        75
```

* Q2: _Compute the turnaround and wait time for each process based on the above schedule._

| Process | Turnaround | Wait |
|---------|------------|------|
| A       | 65         | 35   |
| B       | 75         | 50   |
| C       | 40         | 25   |
| D       | 40         | 35   |

## Threads and memory

* Threads are multiple execution contexts within the **same process**
    * Processes are multiple execution contexts within the **same machine**
* Because threads are within the same process, they share all of the process’s resources — memory, CPU time, file descriptors (i.e., open files), etc.
* Consequently, two threads can update the same variable

* Example


```c
#include <stdio.h>
#include <stdlib.h>
void *thread1_main(void *arg) {
    int *x = (int *)arg;
    *x += 1;
    return NULL;
}
void *thread2_main(void *arg) {
    int *y = (int *)arg;
    *y += 2;
    return NULL;
}
int main() {
    int *z = malloc(sizeof(int));
    *z = 0;
    // Create thread running thread1_main(z)
    // Create thread running thread2_main(z)
    // Wait for threads to finish
    printf("z is %d\n", *z);
}
```

```
z is 3
```

* Two processes cannot update the same variable — memory is not shared; must use inter-process communication mechanism to share information

* Q3: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
void *thread_main(void *arg) {
    char *id = (char *)arg;
    printf("I am thread %c\n", *id);
    return NULL;
}
int main() {
    char *a = malloc(sizeof(char));
    *a = 'A';
    char *b = malloc(sizeof(char));
    *b = 'B';
    // Create thread running thread_main(a)
    // Create thread running thread_main(b)
    // Wait for threads to finish
}
```

```
I am thread A
I am thread B
```
OR
```
I am thread B
I am thread A
```

## Pthreads API

* Can create and wait for threads to finish, just like processes, but API is different
* Use the pthreads library—`#include <pthread.h>`
* `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void*), void * arg)`
    * `thread`—a struct that stores metadata for the thread
    * `attr`—configuration settings for the thread
    * `start_routine`—the function to start executing when the thread starts
        * Pass a pointer to a function
    * `arg`—an argument passed to the aforementioned function
    * _How do we create a new process?_—`fork`
* `int pthread_join(pthread_t thread, void **value_ptr)`
    * `thread`—the same struct passed at thread creation; used to identify the thread we want to wait for
    * `value_ptr`—the location where the function return value should be stored
        * Notice it’s a pointer to a void pointer and the `start_routine` function specified in create returns a void pointer
    * _How do we wait for a process to finish?_ — `wait` or `waitpid`

* Q4: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
void *increment(void *arg) {
    int *num = (int*)arg;
    *num += 1;
    return NULL;
}
void *zero(void *arg) {
    int *num = (int*)arg;
    *num = 0;
    return NULL;
}
int main() {
    pthread_t thread1, thread2;
    int *i = malloc(sizeof(int));
    *i = 5;
    pthread_create(&thread1, NULL, &increment, i);
    pthread_create(&thread2, NULL, &zero, i);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    printf("i=%d\n", *i);
}
```

```
i=0
```
OR
```
i=1
```

* Q5: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
void *printer(void *arg) {
    char *ch = (char*)arg;
    printf("I am %c\n", *ch);
    return NULL;
}
int main() {
    pthread_t thread1, thread2;
    char *ch = malloc(sizeof(char));
    *ch = 'P';
    pthread_create(&thread1, NULL, &printer, ch);
    pthread_join(thread1, NULL);
    *ch = 'Q';
    pthread_create(&thread2, NULL, &printer, ch);
    pthread_join(thread2, NULL);
}
```

    I am P
    I am Q


## Creating multiple threads

* Create an array of `pthread_t` and an array of arguments
* Call `pthread_create` within a loop
* Call `pthread_join` within a separate loop
* Example


```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#define NUM_THREADS 5
void *simple(void *arg) {
    int *id = (int *)arg;
    printf("I am thread %d\n", *id);
    return NULL;
}
int main() {
    pthread_t threads[NUM_THREADS];
    int ids[NUM_THREADS];
    for (int i = 0; i < NUM_THREADS; i++) {
        ids[i] = i+1;
        pthread_create(&(threads[i]), NULL, &simple, &(ids[i]));
    } 
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }
    printf("All threads finished\n");
}
```

    I am thread 2
    I am thread 3
    I am thread 4
    I am thread 5
    I am thread 1
    All threads finished


## Returning values from threads

* _When does a thread end?_ — when the function passed to `pthread_create` finishes (i.e., returns)
* _What happens to a function's parameters and local variables when the function returns?_ — they no longer exist (i.e., the stack frame is destroyed)
* _Where should we store a value that should exist even after a function returns?_ — on the heap
* Need to store a thread's return value on the heap
* Thread returns a pointer to the value on the heap
* Example


```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
void *length(void *arg) {
    char *str = (char *)arg;
    int *len = malloc(sizeof(int));
    *len = strlen(str);
    return len;
}
int main() {
    pthread_t thread;
    char *phrase = "Hello, threads!";
    pthread_create(&thread, NULL, &length, phrase);
    int *result = NULL;
    pthread_join(thread, (void **)&result);
    printf("Length: %d\n", *result);
    free(result);
}
```

    Length: 15


* `pthread_join` returns `0` if successful, or an error number
* To get the pointer returned by the thread, we need to pass a location where the pointer can be stored — i.e., we need to pass a double pointer

## Passing multiple parameters to threads

* A thread can only take a single `void *` pointer as a parameter
* To pass multiple parameters:
    * Define a `struct` that contains a field for each of the parameters
    * Allocate space for an instance of the `struct`
    * Pass a pointer to the instance to the thread — i.e., as the last parameter in `pthread_create`

## Extra practice

* Q6: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
void *printer(void *arg) {
    char *ch = (char*)arg;
    printf("I am %c\n", *ch);
    return NULL;
}
int main() {
    pthread_t thread1, thread2;
    char *ch = malloc(sizeof(char));
    *ch = 'A';
    pthread_create(&thread1, NULL, &printer, ch);
    *ch = 'B';
    pthread_create(&thread2, NULL, &printer, ch);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
}
```

```
I am A
I am B
```
OR
```
I am B
I am B
```

* Q7: _What are all possible outputs produced by this program?_


```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
void *printer2(void *arg) {
    char *ch = (char*)arg;
    printf("Start %c\n", *ch);
    printf("End %c\n", *ch);
    return NULL;
}
int main() {
    pthread_t thread1, thread2;
    char *ch1 = malloc(sizeof(char));
    *ch1 = 'X';
    char *ch2 = malloc(sizeof(char));
    *ch2 = 'Y';
    pthread_create(&thread1, NULL, &printer2, ch1);
    pthread_create(&thread2, NULL, &printer2, ch2);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
}
```

```
Start X
End X
Start Y
End Y
```
OR
```
Start Y
End Y
Start X
End X
```
OR
```
Start X
Start Y
End Y
End X
```
OR
```
Start X
Start Y
End X
End Y
```
OR
```
Start Y
Start X
End X
End Y
```
OR
```
Start Y
Start X
End Y
End X
```
